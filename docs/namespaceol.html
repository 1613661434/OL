<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OL: ol 命名空间参考</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="OL.png"/></td>
  <td id="projectalign">
   <div id="projectname">OL<span id="projectnumber">&#160;Version 0.0.1</span>
   </div>
   <div id="projectbrief">This is a C++ library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','搜索',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespaceol.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">载入中...</div>
<div class="SRStatus" id="Searching">搜索中...</div>
<div class="SRStatus" id="NoMatches">未找到</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">ol 命名空间参考</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
命名空间</h2></td></tr>
<tr class="memitem:base" id="r_base"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceol_1_1base.html">base</a></td></tr>
<tr class="memitem:mysql" id="r_mysql"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceol_1_1mysql.html">mysql</a></td></tr>
<tr class="memitem:oracle" id="r_oracle"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceol_1_1oracle.html">oracle</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
类</h2></td></tr>
<tr class="memitem:binary_5Ft" id="r_binary_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structol_1_1binary__t.html">binary_t</a></td></tr>
<tr class="memitem:BITree" id="r_BITree"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_b_i_tree.html">BITree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">树状数组|二叉索引树（Binary Indexed Tree，BIT）模板类 适用于高效的点更新和前缀和查询操作，时间复杂度均为O(log n)  <a href="classol_1_1_b_i_tree.html#details">更多...</a><br /></td></tr>
<tr class="memitem:ccmdstr" id="r_ccmdstr"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1ccmdstr.html">ccmdstr</a></td></tr>
<tr class="memitem:container_5Ftraits" id="r_container_5Ftraits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structol_1_1container__traits.html">container_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">容器特性萃取模板，统一STL容器和原生数组的操作接口  <a href="structol_1_1container__traits.html#details">更多...</a><br /></td></tr>
<tr class="memitem:container_5Ftraits_3C_20T_5BN_5D_3E" id="r_container_5Ftraits_3C_20T_5BN_5D_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structol_1_1container__traits_3_01_t_0f_n_0e_4.html">container_traits&lt; T[N]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">容器特性萃取模板特化（原生数组）  <a href="structol_1_1container__traits_3_01_t_0f_n_0e_4.html#details">更多...</a><br /></td></tr>
<tr class="memitem:cqueue" id="r_cqueue"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1cqueue.html">cqueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">循环队列模板类 基于静态数组实现，大小固定，支持高效的FIFO（先进先出）操作  <a href="classol_1_1cqueue.html#details">更多...</a><br /></td></tr>
<tr class="memitem:ctimer" id="r_ctimer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1ctimer.html">ctimer</a></td></tr>
<tr class="memitem:Edge" id="r_Edge"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structol_1_1_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">边结构，根据图的配置动态调整是否包含权重 模板参数：  <a href="structol_1_1_edge.html#details">更多...</a><br /></td></tr>
<tr class="memitem:Graph" id="r_Graph"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_graph.html">Graph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">通用图模板类，支持有向/无向、有权/无权配置 模板参数：  <a href="classol_1_1_graph.html#details">更多...</a><br /></td></tr>
<tr class="memitem:IsTypeEmpty" id="r_IsTypeEmpty"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structol_1_1_is_type_empty.html">IsTypeEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">检查类型是否为ol::TypeEmpty类型  <a href="structol_1_1_is_type_empty.html#details">更多...</a><br /></td></tr>
<tr class="memitem:spin_5Fmutex" id="r_spin_5Fmutex"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1spin__mutex.html">spin_mutex</a></td></tr>
<tr class="memitem:ThreadPool" id="r_ThreadPool"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_thread_pool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">线程池模板类，支持动态/固定两种工作模式  <a href="classol_1_1_thread_pool.html#details">更多...</a><br /></td></tr>
<tr class="memitem:TimeStamp" id="r_TimeStamp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_time_stamp.html">TimeStamp</a></td></tr>
<tr class="memitem:TrieMap" id="r_TrieMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_trie_map.html">TrieMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie树键值对映射类（TrieMap）  <a href="classol_1_1_trie_map.html#details">更多...</a><br /></td></tr>
<tr class="memitem:TrieNode" id="r_TrieNode"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_trie_node.html">TrieNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie树的节点类，存储单个字符对应的状态  <a href="classol_1_1_trie_node.html#details">更多...</a><br /></td></tr>
<tr class="memitem:TrieSet" id="r_TrieSet"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_trie_set.html">TrieSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trie树实现的字符串集合类（TrieSet）  <a href="classol_1_1_trie_set.html#details">更多...</a><br /></td></tr>
<tr class="memitem:TypeEmpty" id="r_TypeEmpty"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structol_1_1_type_empty.html">TypeEmpty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">空结构体标记，用于模板中需要占位但不占用内存的场景  <a href="structol_1_1_type_empty.html#details">更多...</a><br /></td></tr>
<tr class="memitem:TypeNonCopyable" id="r_TypeNonCopyable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_type_non_copyable.html">TypeNonCopyable</a></td></tr>
<tr class="memitem:TypeNonCopyableMovable" id="r_TypeNonCopyableMovable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_type_non_copyable_movable.html">TypeNonCopyableMovable</a></td></tr>
<tr class="memitem:TypeNonMovable" id="r_TypeNonMovable"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_type_non_movable.html">TypeNonMovable</a></td></tr>
<tr class="memitem:TypeSingleton" id="r_TypeSingleton"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_type_singleton.html">TypeSingleton</a></td></tr>
<tr class="memitem:UnionFind" id="r_UnionFind"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_union_find.html">UnionFind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">并查集（Union-Find）模板类，用于管理不相交集合的合并与查询  <a href="classol_1_1_union_find.html#details">更多...</a><br /></td></tr>
<tr class="memitem:UnionFind_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fintegral_5Fv_3C_20T_20_3E_20_3E_20_3E" id="r_UnionFind_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fintegral_5Fv_3C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_union_find_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01_t_01_4_01_4_01_4.html">UnionFind&lt; T, std::enable_if_t&lt; std::is_integral_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">并查集针对整数类型的特化实现  <a href="classol_1_1_union_find_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__integral__v_3_01_t_01_4_01_4_01_4.html#details">更多...</a><br /></td></tr>
<tr class="memitem:UnionFind_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_21std_3A_3Ais_5Fintegral_5Fv_3C_20T_20_3E_20_3E_20_3E" id="r_UnionFind_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_21std_3A_3Ais_5Fintegral_5Fv_3C_20T_20_3E_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classol_1_1_union_find_3_01_t_00_01std_1_1enable__if__t_3_9std_1_1is__integral__v_3_01_t_01_4_01_4_01_4.html">UnionFind&lt; T, std::enable_if_t&lt;!std::is_integral_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">并查集针对非整数类型的通用实现  <a href="classol_1_1_union_find_3_01_t_00_01std_1_1enable__if__t_3_9std_1_1is__integral__v_3_01_t_01_4_01_4_01_4.html#details">更多...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
函数</h2></td></tr>
<tr class="memitem:a36c493150bfdebc6e1bf8730c199a586" id="r_a36c493150bfdebc6e1bf8730c199a586"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36c493150bfdebc6e1bf8730c199a586">ltime</a> (char *strtime, const std::string &amp;fmt=&quot;&quot;, const int timetvl=0)</td></tr>
<tr class="memdesc:a36c493150bfdebc6e1bf8730c199a586"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取操作系统时间并格式化为C字符串  <br /></td></tr>
<tr class="memitem:a9a0ee46add8be93066238f466ac013c4" id="r_a9a0ee46add8be93066238f466ac013c4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a0ee46add8be93066238f466ac013c4">ltime</a> (std::string &amp;strtime, const std::string &amp;fmt=&quot;&quot;, const int timetvl=0)</td></tr>
<tr class="memdesc:a9a0ee46add8be93066238f466ac013c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取操作系统时间并格式化为字符串  <br /></td></tr>
<tr class="memitem:a962ba22413633f2e0befb733d150aa32" id="r_a962ba22413633f2e0befb733d150aa32"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962ba22413633f2e0befb733d150aa32">ltime1</a> (const std::string &amp;fmt=&quot;&quot;, const int timetvl=0)</td></tr>
<tr class="memdesc:a962ba22413633f2e0befb733d150aa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">获取操作系统时间并格式化为字符串（无参数重载，避免歧义）  <br /></td></tr>
<tr class="memitem:a2c55f2b104a188a483760fb331340dc3" id="r_a2c55f2b104a188a483760fb331340dc3"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c55f2b104a188a483760fb331340dc3">timetostr</a> (const time_t ttime, std::string &amp;strtime, const std::string &amp;fmt=&quot;&quot;)</td></tr>
<tr class="memdesc:a2c55f2b104a188a483760fb331340dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">将时间戳转换为指定格式的字符串  <br /></td></tr>
<tr class="memitem:a928e01ea34268dd0f9f61c80c6c31ffe" id="r_a928e01ea34268dd0f9f61c80c6c31ffe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928e01ea34268dd0f9f61c80c6c31ffe">timetostr</a> (const time_t ttime, char *strtime, const std::string &amp;fmt=&quot;&quot;)</td></tr>
<tr class="memdesc:a928e01ea34268dd0f9f61c80c6c31ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">将时间戳转换为指定格式的C字符串  <br /></td></tr>
<tr class="memitem:ab4a3cda5dddfd5f15e708b6709b7d375" id="r_ab4a3cda5dddfd5f15e708b6709b7d375"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4a3cda5dddfd5f15e708b6709b7d375">timetostr1</a> (const time_t ttime, const std::string &amp;fmt=&quot;&quot;)</td></tr>
<tr class="memdesc:ab4a3cda5dddfd5f15e708b6709b7d375"><td class="mdescLeft">&#160;</td><td class="mdescRight">将时间戳转换为指定格式的字符串（无参数重载，避免歧义）  <br /></td></tr>
<tr class="memitem:a784ec116a1e64ce61b14a1b727ef474f" id="r_a784ec116a1e64ce61b14a1b727ef474f"><td class="memItemLeft" align="right" valign="top">time_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a784ec116a1e64ce61b14a1b727ef474f">strtotime</a> (const std::string &amp;strtime)</td></tr>
<tr class="memdesc:a784ec116a1e64ce61b14a1b727ef474f"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串转换为时间戳  <br /></td></tr>
<tr class="memitem:acf9a21b41519ca80193f3b673fbaf5cb" id="r_acf9a21b41519ca80193f3b673fbaf5cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9a21b41519ca80193f3b673fbaf5cb">addtime</a> (const std::string &amp;in_stime, std::string &amp;out_stime, const int timetvl, const std::string &amp;fmt=&quot;&quot;)</td></tr>
<tr class="memdesc:acf9a21b41519ca80193f3b673fbaf5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">对时间字符串进行偏移计算（std::string版本）  <br /></td></tr>
<tr class="memitem:a415900cc65a556be1e3ad4765e3d1508" id="r_a415900cc65a556be1e3ad4765e3d1508"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a415900cc65a556be1e3ad4765e3d1508">addtime</a> (const std::string &amp;in_stime, char *out_stime, const int timetvl, const std::string &amp;fmt=&quot;&quot;)</td></tr>
<tr class="memdesc:a415900cc65a556be1e3ad4765e3d1508"><td class="mdescLeft">&#160;</td><td class="mdescRight">对时间字符串进行偏移计算（C字符串版本）  <br /></td></tr>
<tr class="memitem:ac7f241e197b4aee31bccfa11bc58d5d3" id="r_ac7f241e197b4aee31bccfa11bc58d5d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7f241e197b4aee31bccfa11bc58d5d3">ACCESS</a> (const char *_FileName, int _AccessMode)</td></tr>
<tr class="memitem:a1c82ae7c3647a9c5000f2e8bcd4cecc1" id="r_a1c82ae7c3647a9c5000f2e8bcd4cecc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c82ae7c3647a9c5000f2e8bcd4cecc1">MKDIR</a> (const char *_Path, unsigned int _Mode)</td></tr>
<tr class="memitem:a82796b31d32a613c8c1ec8423c5bfe32" id="r_a82796b31d32a613c8c1ec8423c5bfe32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82796b31d32a613c8c1ec8423c5bfe32">newdir</a> (const std::string &amp;pathorfilename, bool bisfilename)</td></tr>
<tr class="memitem:a8cdca00eeb0b403f77ac67300e093843" id="r_a8cdca00eeb0b403f77ac67300e093843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cdca00eeb0b403f77ac67300e093843">renamefile</a> (const std::string &amp;srcfilename, const std::string &amp;dstfilename)</td></tr>
<tr class="memitem:aba683542bcc3658cee4ba7a7dc5f5455" id="r_aba683542bcc3658cee4ba7a7dc5f5455"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba683542bcc3658cee4ba7a7dc5f5455">copyfile</a> (const std::string &amp;srcfilename, const std::string &amp;dstfilename)</td></tr>
<tr class="memitem:a9678bc0f8ed0f972cf1948293d920372" id="r_a9678bc0f8ed0f972cf1948293d920372"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9678bc0f8ed0f972cf1948293d920372">filesize</a> (const std::string &amp;filename)</td></tr>
<tr class="memitem:ab3e74e09a9d9b181d71bda70bbe4eeaa" id="r_ab3e74e09a9d9b181d71bda70bbe4eeaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e74e09a9d9b181d71bda70bbe4eeaa">filemtime</a> (const std::string &amp;filename, std::string &amp;mtime, const std::string &amp;fmt)</td></tr>
<tr class="memitem:ad40bbc392d95b486ce6ea0dc229ed00b" id="r_ad40bbc392d95b486ce6ea0dc229ed00b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40bbc392d95b486ce6ea0dc229ed00b">filemtime</a> (const std::string &amp;filename, char *mtime, const std::string &amp;fmt)</td></tr>
<tr class="memitem:a4fee6ef354270ebe2c9a5bc156dfad87" id="r_a4fee6ef354270ebe2c9a5bc156dfad87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fee6ef354270ebe2c9a5bc156dfad87">setmtime</a> (const std::string &amp;filename, const std::string &amp;mtime)</td></tr>
<tr class="memitem:a1da95e0d0c4e69dcdd873a550bf4b64c" id="r_a1da95e0d0c4e69dcdd873a550bf4b64c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da95e0d0c4e69dcdd873a550bf4b64c">nl</a> (std::ostream &amp;os)</td></tr>
<tr class="memdesc:a1da95e0d0c4e69dcdd873a550bf4b64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">自定义换行操纵符（替代endl，不刷新缓冲区）  <br /></td></tr>
<tr class="memitem:a4b5adf474f85a8a0166456640fb6f2ec" id="r_a4b5adf474f85a8a0166456640fb6f2ec"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b5adf474f85a8a0166456640fb6f2ec">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structol_1_1binary__t.html">binary_t</a> &amp;b)</td></tr>
<tr class="memitem:a8b8a16c2b2b49e295d7299a8922eb40e" id="r_a8b8a16c2b2b49e295d7299a8922eb40e"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b8a16c2b2b49e295d7299a8922eb40e">clearbuf</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a8b8a16c2b2b49e295d7299a8922eb40e"><td class="mdescLeft">&#160;</td><td class="mdescRight">清空输入缓冲区（忽略剩余字符直到换行）  <br /></td></tr>
<tr class="memitem:a6b9e6cdd4877ca3d4ae2b903284b3c02" id="r_a6b9e6cdd4877ca3d4ae2b903284b3c02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b9e6cdd4877ca3d4ae2b903284b3c02">Bisection_Method</a> (double(*func)(double), double low, double high, double tolerance, const size_t max_iterations=1000)</td></tr>
<tr class="memdesc:a6b9e6cdd4877ca3d4ae2b903284b3c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">二分迭代法求解非线性方程（收敛阶P=1）  <br /></td></tr>
<tr class="memitem:af1d7513132d32e7236d0c253e16fcb0f" id="r_af1d7513132d32e7236d0c253e16fcb0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1d7513132d32e7236d0c253e16fcb0f">Simple_Iteration_Method</a> (double(*iter_func)(double), double initial_value, double tolerance, const size_t max_iterations=1000)</td></tr>
<tr class="memdesc:af1d7513132d32e7236d0c253e16fcb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">简单迭代法求解非线性方程（收敛阶P=1）  <br /></td></tr>
<tr class="memitem:a04b2c9f90ab67dc3eb8ba95a9731b250" id="r_a04b2c9f90ab67dc3eb8ba95a9731b250"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04b2c9f90ab67dc3eb8ba95a9731b250">Newton_Method</a> (double(*func)(double), double(*der_func)(double), double initial_value, double tolerance, const size_t max_iterations=1000)</td></tr>
<tr class="memdesc:a04b2c9f90ab67dc3eb8ba95a9731b250"><td class="mdescLeft">&#160;</td><td class="mdescRight">牛顿迭代法求解非线性方程（收敛阶P=2）  <br /></td></tr>
<tr class="memitem:a1c04a27f537065c8da7b1b676535ca94" id="r_a1c04a27f537065c8da7b1b676535ca94"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c04a27f537065c8da7b1b676535ca94">Secant_Method</a> (double(*func)(double), double initial_value_0, double initial_value_1, double tolerance, const size_t max_iterations=1000, bool isFixedPoint_0=false)</td></tr>
<tr class="memdesc:a1c04a27f537065c8da7b1b676535ca94"><td class="mdescLeft">&#160;</td><td class="mdescRight">弦截迭代法求解非线性方程（收敛阶P=1.618）  <br /></td></tr>
<tr class="memitem:aaa16280e711fcd7aaa7b1b6f4a23857d" id="r_aaa16280e711fcd7aaa7b1b6f4a23857d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa16280e711fcd7aaa7b1b6f4a23857d">deleteLchr</a> (char *str, const char c=' ')</td></tr>
<tr class="memdesc:aaa16280e711fcd7aaa7b1b6f4a23857d"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除字符串左边指定字符  <br /></td></tr>
<tr class="memitem:a745779345fb05a962ec85f810354431a" id="r_a745779345fb05a962ec85f810354431a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a745779345fb05a962ec85f810354431a">deleteLchr</a> (std::string &amp;str, const char c)</td></tr>
<tr class="memitem:ac480ad633ab9f2ed59990a7996f172b1" id="r_ac480ad633ab9f2ed59990a7996f172b1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac480ad633ab9f2ed59990a7996f172b1">deleteRchr</a> (char *str, const char c=' ')</td></tr>
<tr class="memdesc:ac480ad633ab9f2ed59990a7996f172b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除字符串右边指定字符  <br /></td></tr>
<tr class="memitem:a6c3e6a85af26aaaa9c96d687cffd8f49" id="r_a6c3e6a85af26aaaa9c96d687cffd8f49"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c3e6a85af26aaaa9c96d687cffd8f49">deleteRchr</a> (std::string &amp;str, const char c)</td></tr>
<tr class="memitem:a88a6fb332655c644005654d323513378" id="r_a88a6fb332655c644005654d323513378"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88a6fb332655c644005654d323513378">deleteLRchr</a> (char *str, const char c=' ')</td></tr>
<tr class="memdesc:a88a6fb332655c644005654d323513378"><td class="mdescLeft">&#160;</td><td class="mdescRight">删除字符串左右两边指定字符  <br /></td></tr>
<tr class="memitem:ae4294d63773fe865b4000cc5c43c902f" id="r_ae4294d63773fe865b4000cc5c43c902f"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4294d63773fe865b4000cc5c43c902f">deleteLRchr</a> (std::string &amp;str, const char c)</td></tr>
<tr class="memitem:a3f3142917106949a00dbabce5cd4dd62" id="r_a3f3142917106949a00dbabce5cd4dd62"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f3142917106949a00dbabce5cd4dd62">toupper</a> (char *str)</td></tr>
<tr class="memdesc:a3f3142917106949a00dbabce5cd4dd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串中的小写字母转换为大写（非字母字符不变）  <br /></td></tr>
<tr class="memitem:ace14bdaa9a2d54bff9ba3b43e3f4f079" id="r_ace14bdaa9a2d54bff9ba3b43e3f4f079"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace14bdaa9a2d54bff9ba3b43e3f4f079">toupper</a> (std::string &amp;str)</td></tr>
<tr class="memitem:a251bbe056574349c9b660013001d8120" id="r_a251bbe056574349c9b660013001d8120"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251bbe056574349c9b660013001d8120">tolower</a> (char *str)</td></tr>
<tr class="memdesc:a251bbe056574349c9b660013001d8120"><td class="mdescLeft">&#160;</td><td class="mdescRight">将字符串中的大写字母转换为小写（非字母字符不变）  <br /></td></tr>
<tr class="memitem:a5a85db488b024565411ab4fe77f00c43" id="r_a5a85db488b024565411ab4fe77f00c43"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a85db488b024565411ab4fe77f00c43">tolower</a> (std::string &amp;str)</td></tr>
<tr class="memitem:a6efd74ce91343f9d51b7820f4b65663b" id="r_a6efd74ce91343f9d51b7820f4b65663b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6efd74ce91343f9d51b7820f4b65663b">replacestr</a> (std::string &amp;str, const std::string &amp;str1, const std::string &amp;str2, bool bloop)</td></tr>
<tr class="memitem:acac3b36117c350b30d7627c06dee201c" id="r_acac3b36117c350b30d7627c06dee201c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acac3b36117c350b30d7627c06dee201c">replacestr</a> (char *str, const std::string &amp;str1, const std::string &amp;str2, const bool bloop=false)</td></tr>
<tr class="memdesc:acac3b36117c350b30d7627c06dee201c"><td class="mdescLeft">&#160;</td><td class="mdescRight">字符串替换  <br /></td></tr>
<tr class="memitem:ac81c63f2b04e9efd21292fdfe4ed7a41" id="r_ac81c63f2b04e9efd21292fdfe4ed7a41"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac81c63f2b04e9efd21292fdfe4ed7a41">picknumber</a> (const std::string &amp;src, char *dest, const bool bsigned=false, const bool bdot=false)</td></tr>
<tr class="memdesc:ac81c63f2b04e9efd21292fdfe4ed7a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">从字符串中提取数字相关字符  <br /></td></tr>
<tr class="memitem:a1234d4c4cabd00d7c6ec033c3b3427d9" id="r_a1234d4c4cabd00d7c6ec033c3b3427d9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1234d4c4cabd00d7c6ec033c3b3427d9">picknumber</a> (const std::string &amp;src, std::string &amp;dest, const bool bsigned, const bool bdot)</td></tr>
<tr class="memitem:a4572f642a9fbea8c13a237366bb949f6" id="r_a4572f642a9fbea8c13a237366bb949f6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4572f642a9fbea8c13a237366bb949f6">picknumber</a> (const std::string &amp;src, const bool bsigned, const bool bdot)</td></tr>
<tr class="memitem:ad26f3aeccdfe4a26275ae2408a199ace" id="r_ad26f3aeccdfe4a26275ae2408a199ace"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad26f3aeccdfe4a26275ae2408a199ace">matchstr</a> (const std::string &amp;str, const std::string &amp;rules)</td></tr>
<tr class="memdesc:ad26f3aeccdfe4a26275ae2408a199ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">正则匹配字符串（支持通配符*，匹配多个任意字符）  <br /></td></tr>
<tr class="memitem:a4c80a2de27f0a49c96e7884d5a904982" id="r_a4c80a2de27f0a49c96e7884d5a904982"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c80a2de27f0a49c96e7884d5a904982">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classol_1_1ccmdstr.html">ccmdstr</a> &amp;cmdstr)</td></tr>
<tr class="memdesc:a4c80a2de27f0a49c96e7884d5a904982"><td class="mdescLeft">&#160;</td><td class="mdescRight">重载&lt;&lt;运算符，输出ccmdstr的字段内容（调试用）  <br /></td></tr>
<tr class="memitem:ab50670b26462f76a11a18ed002f00db9" id="r_ab50670b26462f76a11a18ed002f00db9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab50670b26462f76a11a18ed002f00db9">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, std::string &amp;value, const size_t len)</td></tr>
<tr class="memitem:a4c84b0c2d8eef3aadcce9253463cd5d3" id="r_a4c84b0c2d8eef3aadcce9253463cd5d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c84b0c2d8eef3aadcce9253463cd5d3">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, char *value, const size_t len)</td></tr>
<tr class="memitem:a7b6934046eb299f6624cf045d94beefd" id="r_a7b6934046eb299f6624cf045d94beefd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b6934046eb299f6624cf045d94beefd">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, bool &amp;value)</td></tr>
<tr class="memitem:ab556e056cad32562d315e750ea0b8839" id="r_ab556e056cad32562d315e750ea0b8839"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab556e056cad32562d315e750ea0b8839">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, int &amp;value)</td></tr>
<tr class="memitem:a3faacb9189f20800d49da807fa74ca7e" id="r_a3faacb9189f20800d49da807fa74ca7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3faacb9189f20800d49da807fa74ca7e">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, unsigned int &amp;value)</td></tr>
<tr class="memitem:a2964a31677b6de3ef5d7ef1686999cb2" id="r_a2964a31677b6de3ef5d7ef1686999cb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2964a31677b6de3ef5d7ef1686999cb2">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, long &amp;value)</td></tr>
<tr class="memitem:ab225c4f858f9e16809cdbfdda55e1feb" id="r_ab225c4f858f9e16809cdbfdda55e1feb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab225c4f858f9e16809cdbfdda55e1feb">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, unsigned long &amp;value)</td></tr>
<tr class="memitem:a3c709bf27e30aef5c100784c624134d6" id="r_a3c709bf27e30aef5c100784c624134d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c709bf27e30aef5c100784c624134d6">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, double &amp;value)</td></tr>
<tr class="memitem:a3dbe1785f618ada77a6bf154c5475db5" id="r_a3dbe1785f618ada77a6bf154c5475db5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3dbe1785f618ada77a6bf154c5475db5">getByXml</a> (const std::string &amp;xmlStr, const std::string &amp;tag, float &amp;value)</td></tr>
<tr class="memitem:a893e7d35ae9b6ac8e3cb9570ccf72894" id="r_a893e7d35ae9b6ac8e3cb9570ccf72894"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a893e7d35ae9b6ac8e3cb9570ccf72894">skmp</a> (const std::string &amp;str, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:a893e7d35ae9b6ac8e3cb9570ccf72894"><td class="mdescLeft">&#160;</td><td class="mdescRight">KMP算法查找子串  <br /></td></tr>
<tr class="memitem:aa8bc0ef20d6a5f982723bcc3c595c077" id="r_aa8bc0ef20d6a5f982723bcc3c595c077"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8bc0ef20d6a5f982723bcc3c595c077">localtime_now</a> (struct tm *tm_out, const time_t *t)</td></tr>
<tr class="memitem:a8ab0387cd3663518222d4fc4b0d5cc0b" id="r_a8ab0387cd3663518222d4fc4b0d5cc0b"><td class="memTemplParams" colspan="2">template&lt;typename Rep, typename Period&gt; </td></tr>
<tr class="memitem:a8ab0387cd3663518222d4fc4b0d5cc0b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ab0387cd3663518222d4fc4b0d5cc0b">sleep</a> (std::chrono::duration&lt; Rep, Period &gt; duration)</td></tr>
<tr class="memdesc:a8ab0387cd3663518222d4fc4b0d5cc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">通用休眠函数（支持任意时间单位）  <br /></td></tr>
<tr class="memitem:aee164d17dc0777c945a2dd47bbd8443f" id="r_aee164d17dc0777c945a2dd47bbd8443f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee164d17dc0777c945a2dd47bbd8443f">sleep_ns</a> (long long nanoseconds)</td></tr>
<tr class="memdesc:aee164d17dc0777c945a2dd47bbd8443f"><td class="mdescLeft">&#160;</td><td class="mdescRight">纳秒级休眠  <br /></td></tr>
<tr class="memitem:a48224ad9e2c21e51b9e301c287cd3aa0" id="r_a48224ad9e2c21e51b9e301c287cd3aa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48224ad9e2c21e51b9e301c287cd3aa0">sleep_us</a> (long long microseconds)</td></tr>
<tr class="memdesc:a48224ad9e2c21e51b9e301c287cd3aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">微秒级休眠  <br /></td></tr>
<tr class="memitem:a82a6a51dbf9dc8c1ba527e70b1f8707c" id="r_a82a6a51dbf9dc8c1ba527e70b1f8707c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82a6a51dbf9dc8c1ba527e70b1f8707c">sleep_ms</a> (long long milliseconds)</td></tr>
<tr class="memdesc:a82a6a51dbf9dc8c1ba527e70b1f8707c"><td class="mdescLeft">&#160;</td><td class="mdescRight">毫秒级休眠  <br /></td></tr>
<tr class="memitem:ac624dba15a65798fc097dc515022c249" id="r_ac624dba15a65798fc097dc515022c249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac624dba15a65798fc097dc515022c249">sleep_sec</a> (long long seconds)</td></tr>
<tr class="memdesc:ac624dba15a65798fc097dc515022c249"><td class="mdescLeft">&#160;</td><td class="mdescRight">秒级休眠  <br /></td></tr>
<tr class="memitem:adc296ca0e424c95936114c0d1251266d" id="r_adc296ca0e424c95936114c0d1251266d"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:adc296ca0e424c95936114c0d1251266d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structol_1_1binary__t.html">binary_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc296ca0e424c95936114c0d1251266d">binary</a> (T value)</td></tr>
<tr class="memdesc:adc296ca0e424c95936114c0d1251266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">二进制输出辅助函数  <br /></td></tr>
<tr class="memitem:a34677863ef2e6cb4d453190485e82f2e" id="r_a34677863ef2e6cb4d453190485e82f2e"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a34677863ef2e6cb4d453190485e82f2e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34677863ef2e6cb4d453190485e82f2e">hash_combine</a> (std::size_t &amp;seed, const T &amp;val)</td></tr>
<tr class="memdesc:a34677863ef2e6cb4d453190485e82f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">哈希组合函数：将单个值的哈希值合并到种子中  <br /></td></tr>
<tr class="memitem:aaf2df6d5aad0a8b4951d6219e5179f8b" id="r_aaf2df6d5aad0a8b4951d6219e5179f8b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aaf2df6d5aad0a8b4951d6219e5179f8b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf2df6d5aad0a8b4951d6219e5179f8b">hash_val</a> (std::size_t &amp;seed, const T &amp;val)</td></tr>
<tr class="memdesc:aaf2df6d5aad0a8b4951d6219e5179f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">可变参数哈希计算：单参数版本（递归终止函数）  <br /></td></tr>
<tr class="memitem:a066b4213274d02ff0d3029ce1d644c27" id="r_a066b4213274d02ff0d3029ce1d644c27"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Types&gt; </td></tr>
<tr class="memitem:a066b4213274d02ff0d3029ce1d644c27 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a066b4213274d02ff0d3029ce1d644c27">hash_val</a> (std::size_t &amp;seed, const T &amp;val, const Types... args)</td></tr>
<tr class="memdesc:a066b4213274d02ff0d3029ce1d644c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">可变参数哈希计算：多参数递归版本  <br /></td></tr>
<tr class="memitem:a3bd6198b05d3159b49bf4b38c11123f5" id="r_a3bd6198b05d3159b49bf4b38c11123f5"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a3bd6198b05d3159b49bf4b38c11123f5 template"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3bd6198b05d3159b49bf4b38c11123f5">hash_val</a> (const Types... args)</td></tr>
<tr class="memdesc:a3bd6198b05d3159b49bf4b38c11123f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">可变参数哈希计算：入口函数  <br /></td></tr>
<tr class="memitem:ab6ff8f596eb0adeac5de66f9c658c253" id="r_ab6ff8f596eb0adeac5de66f9c658c253"><td class="memTemplParams" colspan="2">template&lt;typename Iterator, typename Compare = std::less&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ab6ff8f596eb0adeac5de66f9c658c253 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ff8f596eb0adeac5de66f9c658c253">insertion_sort</a> (Iterator first, Iterator last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:ab6ff8f596eb0adeac5de66f9c658c253"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a355256f0b51dffd00f26de3e2629c46f" id="r_a355256f0b51dffd00f26de3e2629c46f"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a355256f0b51dffd00f26de3e2629c46f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a355256f0b51dffd00f26de3e2629c46f">insertion_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a355256f0b51dffd00f26de3e2629c46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">插入排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a45db5d3d6fa79c3adb1e07b0873a1cd4" id="r_a45db5d3d6fa79c3adb1e07b0873a1cd4"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a45db5d3d6fa79c3adb1e07b0873a1cd4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45db5d3d6fa79c3adb1e07b0873a1cd4">binary_insertion_sort</a> (RandomIt first, RandomIt last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a45db5d3d6fa79c3adb1e07b0873a1cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">折半插入排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:ab943f27517cb47afd09b32c14080c1a0" id="r_ab943f27517cb47afd09b32c14080c1a0"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ab943f27517cb47afd09b32c14080c1a0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab943f27517cb47afd09b32c14080c1a0">binary_insertion_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:ab943f27517cb47afd09b32c14080c1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">折半插入排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a14ba777d836ccf56aa6eeeaaf0230e34" id="r_a14ba777d836ccf56aa6eeeaaf0230e34"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a14ba777d836ccf56aa6eeeaaf0230e34 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ba777d836ccf56aa6eeeaaf0230e34">shell_sort</a> (RandomIt first, RandomIt last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a14ba777d836ccf56aa6eeeaaf0230e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">希尔排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:abc5f5010f28529925ffb01055683d42c" id="r_abc5f5010f28529925ffb01055683d42c"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:abc5f5010f28529925ffb01055683d42c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc5f5010f28529925ffb01055683d42c">shell_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:abc5f5010f28529925ffb01055683d42c"><td class="mdescLeft">&#160;</td><td class="mdescRight">希尔排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:afd6efc10009da0b60ba08496cf1465e2" id="r_afd6efc10009da0b60ba08496cf1465e2"><td class="memTemplParams" colspan="2">template&lt;typename Iterator, typename Compare = std::less&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:afd6efc10009da0b60ba08496cf1465e2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6efc10009da0b60ba08496cf1465e2">bubble_sort</a> (Iterator first, Iterator last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:afd6efc10009da0b60ba08496cf1465e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">冒泡排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:ac4eba733f62c575369a7442dafb72921" id="r_ac4eba733f62c575369a7442dafb72921"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ac4eba733f62c575369a7442dafb72921 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4eba733f62c575369a7442dafb72921">bubble_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:ac4eba733f62c575369a7442dafb72921"><td class="mdescLeft">&#160;</td><td class="mdescRight">冒泡排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:ab5050dfa7769d72e80979b03d5838d47" id="r_ab5050dfa7769d72e80979b03d5838d47"><td class="memTemplParams" colspan="2">template&lt;typename Iterator, typename Compare = std::less&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ab5050dfa7769d72e80979b03d5838d47 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5050dfa7769d72e80979b03d5838d47">selection_sort</a> (Iterator first, Iterator last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:ab5050dfa7769d72e80979b03d5838d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">选择排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a30335079a85487d189df8d7746b28a04" id="r_a30335079a85487d189df8d7746b28a04"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a30335079a85487d189df8d7746b28a04 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30335079a85487d189df8d7746b28a04">selection_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a30335079a85487d189df8d7746b28a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">选择排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:ad58d66ffb28691d52d0c8a3436efa3a1" id="r_ad58d66ffb28691d52d0c8a3436efa3a1"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ad58d66ffb28691d52d0c8a3436efa3a1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad58d66ffb28691d52d0c8a3436efa3a1">heap_sort</a> (RandomIt first, RandomIt last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:ad58d66ffb28691d52d0c8a3436efa3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">堆排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a8f3964ed496212300b728bbc1548b059" id="r_a8f3964ed496212300b728bbc1548b059"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a8f3964ed496212300b728bbc1548b059 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f3964ed496212300b728bbc1548b059">heap_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a8f3964ed496212300b728bbc1548b059"><td class="mdescLeft">&#160;</td><td class="mdescRight">堆排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:afc1301e964ee0feb56c92811ad669d3c" id="r_afc1301e964ee0feb56c92811ad669d3c"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:afc1301e964ee0feb56c92811ad669d3c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc1301e964ee0feb56c92811ad669d3c">merge_sort</a> (RandomIt first, RandomIt last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:afc1301e964ee0feb56c92811ad669d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">归并排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a8e7cb4d1f4074dfb13359f984db6421b" id="r_a8e7cb4d1f4074dfb13359f984db6421b"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a8e7cb4d1f4074dfb13359f984db6421b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e7cb4d1f4074dfb13359f984db6421b">merge_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a8e7cb4d1f4074dfb13359f984db6421b"><td class="mdescLeft">&#160;</td><td class="mdescRight">归并排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a7f1d9815c8bbf0a5e37466b69ac4154f" id="r_a7f1d9815c8bbf0a5e37466b69ac4154f"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a7f1d9815c8bbf0a5e37466b69ac4154f template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f1d9815c8bbf0a5e37466b69ac4154f">counting_sort</a> (RandomIt first, RandomIt last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a7f1d9815c8bbf0a5e37466b69ac4154f"><td class="mdescLeft">&#160;</td><td class="mdescRight">计数排序（迭代器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:a73bd96b25ae284520474e93e504a04d7" id="r_a73bd96b25ae284520474e93e504a04d7"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a73bd96b25ae284520474e93e504a04d7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; typenamecontainer_traits&lt; Container &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73bd96b25ae284520474e93e504a04d7">counting_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a73bd96b25ae284520474e93e504a04d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">计数排序（容器版本，支持默认比较器）  <br /></td></tr>
<tr class="memitem:ad3a7ae1e3c04b9fb3fe03a8c01767965" id="r_ad3a7ae1e3c04b9fb3fe03a8c01767965"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ad3a7ae1e3c04b9fb3fe03a8c01767965 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3a7ae1e3c04b9fb3fe03a8c01767965">radix_sort_lsd</a> (RandomIt first, RandomIt last, int radix=10, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:ad3a7ae1e3c04b9fb3fe03a8c01767965"><td class="mdescLeft">&#160;</td><td class="mdescRight">基数排序（迭代器版本，LSD策略，适用于整数类型）  <br /></td></tr>
<tr class="memitem:aca3ac38ec67c0284d769deb7d7a543ae" id="r_aca3ac38ec67c0284d769deb7d7a543ae"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:aca3ac38ec67c0284d769deb7d7a543ae template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; typenamecontainer_traits&lt; Container &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3ac38ec67c0284d769deb7d7a543ae">radix_sort_lsd</a> (Container &amp;container, int radix=10, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:aca3ac38ec67c0284d769deb7d7a543ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">基数排序（容器版本，LSD策略，适用于整数类型）  <br /></td></tr>
<tr class="memitem:ab3b54338a25c60a7d48ee493209d675e" id="r_ab3b54338a25c60a7d48ee493209d675e"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt&gt; </td></tr>
<tr class="memitem:ab3b54338a25c60a7d48ee493209d675e template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type, std::string &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3b54338a25c60a7d48ee493209d675e">radix_sort_msd</a> (RandomIt first, RandomIt last, int max_pos=-1, int radix=256)</td></tr>
<tr class="memdesc:ab3b54338a25c60a7d48ee493209d675e"><td class="mdescLeft">&#160;</td><td class="mdescRight">基数排序（迭代器版本，MSD策略，字符串专用）  <br /></td></tr>
<tr class="memitem:a1673c8a78bd795b8fc12136ddb75abd7" id="r_a1673c8a78bd795b8fc12136ddb75abd7"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:a1673c8a78bd795b8fc12136ddb75abd7 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typenamecontainer_traits&lt; Container &gt;::value_type, std::string &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1673c8a78bd795b8fc12136ddb75abd7">radix_sort_msd</a> (Container &amp;container, int max_pos=-1, int radix=256)</td></tr>
<tr class="memdesc:a1673c8a78bd795b8fc12136ddb75abd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">基数排序（容器版本，MSD策略，字符串专用）  <br /></td></tr>
<tr class="memitem:ae7766935138c272ea6c5c41d97b8f9d2" id="r_ae7766935138c272ea6c5c41d97b8f9d2"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:ae7766935138c272ea6c5c41d97b8f9d2 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typenamecontainer_traits&lt; Container &gt;::value_type, std::string &gt;::value, std::vector&lt; Container &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7766935138c272ea6c5c41d97b8f9d2">radix_group_by_prefix</a> (Container &amp;container, size_t group_pos, int radix=256)</td></tr>
<tr class="memdesc:ae7766935138c272ea6c5c41d97b8f9d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">按字符串前缀分组（基于基数排序MSD）  <br /></td></tr>
<tr class="memitem:a20e0ccd87e1ef5296e5b901c6d5f0691" id="r_a20e0ccd87e1ef5296e5b901c6d5f0691"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:a20e0ccd87e1ef5296e5b901c6d5f0691 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20e0ccd87e1ef5296e5b901c6d5f0691">quick_sort</a> (RandomIt first, RandomIt last, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a20e0ccd87e1ef5296e5b901c6d5f0691"><td class="mdescLeft">&#160;</td><td class="mdescRight">快速排序（迭代器版本）  <br /></td></tr>
<tr class="memitem:acba072c1e10da92c9c812e46787ca8dc" id="r_acba072c1e10da92c9c812e46787ca8dc"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:acba072c1e10da92c9c812e46787ca8dc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba072c1e10da92c9c812e46787ca8dc">quick_sort</a> (Container &amp;container, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:acba072c1e10da92c9c812e46787ca8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">快速排序（容器版本）  <br /></td></tr>
<tr class="memitem:aebf9da183c7571fd920489173964fc62" id="r_aebf9da183c7571fd920489173964fc62"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:aebf9da183c7571fd920489173964fc62 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebf9da183c7571fd920489173964fc62">bucket_sort</a> (RandomIt first, RandomIt last, size_t num_buckets=10, double min_val=0.0, double max_val=1.0, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:aebf9da183c7571fd920489173964fc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">桶排序（迭代器版本，适用于浮点数）  <br /></td></tr>
<tr class="memitem:af320799ed43dcad0f83ab6eb81564cff" id="r_af320799ed43dcad0f83ab6eb81564cff"><td class="memTemplParams" colspan="2">template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:af320799ed43dcad0f83ab6eb81564cff template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af320799ed43dcad0f83ab6eb81564cff">bucket_sort</a> (RandomIt first, RandomIt last, size_t num_buckets=10, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:af320799ed43dcad0f83ab6eb81564cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">桶排序（迭代器版本，适用于整数）  <br /></td></tr>
<tr class="memitem:a736b60ebf0649020725abaaee4b9a9f9" id="r_a736b60ebf0649020725abaaee4b9a9f9"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:a736b60ebf0649020725abaaee4b9a9f9 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; typenameContainer::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a736b60ebf0649020725abaaee4b9a9f9">bucket_sort</a> (Container &amp;container, size_t num_buckets=10, double min_val=0.0, double max_val=1.0, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a736b60ebf0649020725abaaee4b9a9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">桶排序（容器版本，适用于浮点数）  <br /></td></tr>
<tr class="memitem:a27228a514c2c9db637e2fa559e4a28e8" id="r_a27228a514c2c9db637e2fa559e4a28e8"><td class="memTemplParams" colspan="2">template&lt;typename Container, typename Compare = std::less&lt;typename Container::value_type&gt;&gt; </td></tr>
<tr class="memitem:a27228a514c2c9db637e2fa559e4a28e8 template"><td class="memItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; typenameContainer::value_type &gt;::value, void &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27228a514c2c9db637e2fa559e4a28e8">bucket_sort</a> (Container &amp;container, size_t num_buckets=10, const Compare &amp;comp=Compare())</td></tr>
<tr class="memdesc:a27228a514c2c9db637e2fa559e4a28e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">桶排序（容器版本，适用于整数）  <br /></td></tr>
<tr class="memitem:ab59144036437a58a1390422ea187c7b7" id="r_ab59144036437a58a1390422ea187c7b7"><td class="memTemplParams" colspan="2">template&lt;typename Container&gt; </td></tr>
<tr class="memitem:ab59144036437a58a1390422ea187c7b7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab59144036437a58a1390422ea187c7b7">print_container</a> (const Container &amp;container)</td></tr>
<tr class="memdesc:ab59144036437a58a1390422ea187c7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">打印容器元素（调试用）  <br /></td></tr>
<tr class="memitem:a53370611a6ca69b5179649d739f98912" id="r_a53370611a6ca69b5179649d739f98912"><td class="memTemplParams" colspan="2">template&lt;typename T, size_t N&gt; </td></tr>
<tr class="memitem:a53370611a6ca69b5179649d739f98912 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53370611a6ca69b5179649d739f98912">print_container</a> (const T(&amp;array)[N])</td></tr>
<tr class="memdesc:a53370611a6ca69b5179649d739f98912"><td class="mdescLeft">&#160;</td><td class="mdescRight">打印原生数组元素（调试用）  <br /></td></tr>
<tr class="memitem:a9be60c7b808dd3c1f3545e4fb187b276" id="r_a9be60c7b808dd3c1f3545e4fb187b276"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a9be60c7b808dd3c1f3545e4fb187b276 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9be60c7b808dd3c1f3545e4fb187b276">sformat</a> (std::string &amp;str, const char *fmt, Types &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9be60c7b808dd3c1f3545e4fb187b276"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化输出函数（写入已有字符串）  <br /></td></tr>
<tr class="memitem:aac494558d01c7d5be3f87d20b0a558f2" id="r_aac494558d01c7d5be3f87d20b0a558f2"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aac494558d01c7d5be3f87d20b0a558f2 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac494558d01c7d5be3f87d20b0a558f2">sformat</a> (const char *fmt, Types &amp;&amp;... args)</td></tr>
<tr class="memdesc:aac494558d01c7d5be3f87d20b0a558f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">格式化输出函数（返回新字符串）  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
变量</h2></td></tr>
<tr class="memitem:a1c4c2cb1e688fe4d998860c92537f43c" id="r_a1c4c2cb1e688fe4d998860c92537f43c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a1c4c2cb1e688fe4d998860c92537f43c template"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c4c2cb1e688fe4d998860c92537f43c">IsTypeEmpty_v</a> = <a class="el" href="structol_1_1_is_type_empty.html">IsTypeEmpty</a>&lt;T&gt;::value</td></tr>
</table>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">函数说明</h2>
<a id="ac7f241e197b4aee31bccfa11bc58d5d3" name="ac7f241e197b4aee31bccfa11bc58d5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f241e197b4aee31bccfa11bc58d5d3">&#9670;&#160;</a></span>ACCESS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ol::ACCESS </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>_FileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>_AccessMode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a415900cc65a556be1e3ad4765e3d1508" name="a415900cc65a556be1e3ad4765e3d1508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415900cc65a556be1e3ad4765e3d1508">&#9670;&#160;</a></span>addtime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::addtime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>in_stime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>out_stime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>timetvl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对时间字符串进行偏移计算（C字符串版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_stime</td><td>输入时间字符串（格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变） </td></tr>
    <tr><td class="paramname">out_stime</td><td>输出偏移后的时间字符串 </td></tr>
    <tr><td class="paramname">timetvl</td><td>偏移秒数（正数为未来，负数为过去） </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功返回true，失败返回false（输入格式错误） </dd></dl>
<dl class="section note"><dt>注解</dt><dd>in_stime和out_stime参数可以是同一个变量的地址，如果调用失败，out_stime的内容会清空。 </dd></dl>

</div>
</div>
<a id="acf9a21b41519ca80193f3b673fbaf5cb" name="acf9a21b41519ca80193f3b673fbaf5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9a21b41519ca80193f3b673fbaf5cb">&#9670;&#160;</a></span>addtime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::addtime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>in_stime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>out_stime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>timetvl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对时间字符串进行偏移计算（std::string版本） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_stime</td><td>输入时间字符串（格式不限，但一定要包括yyyymmddhh24miss，一个都不能少，顺序也不能变） </td></tr>
    <tr><td class="paramname">out_stime</td><td>输出偏移后的时间字符串引用 </td></tr>
    <tr><td class="paramname">timetvl</td><td>偏移秒数 </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>成功返回true，失败返回false </dd></dl>
<dl class="section note"><dt>注解</dt><dd>in_stime和out_stime参数可以是同一个变量的地址，如果调用失败，out_stime的内容会清空。 </dd></dl>

</div>
</div>
<a id="adc296ca0e424c95936114c0d1251266d" name="adc296ca0e424c95936114c0d1251266d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc296ca0e424c95936114c0d1251266d">&#9670;&#160;</a></span>binary()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structol_1_1binary__t.html">binary_t</a> ol::binary </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二进制输出辅助函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>整数类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>待输出的整数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>binary_t结构体 </dd></dl>

</div>
</div>
<a id="ab943f27517cb47afd09b32c14080c1a0" name="ab943f27517cb47afd09b32c14080c1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab943f27517cb47afd09b32c14080c1a0">&#9670;&#160;</a></span>binary_insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::binary_insertion_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>折半插入排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度有关（减少了比较次数但仍需移动元素）</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：中等规模数据，相比普通插入排序减少了比较次数 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a45db5d3d6fa79c3adb1e07b0873a1cd4" name="a45db5d3d6fa79c3adb1e07b0873a1cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45db5d3d6fa79c3adb1e07b0873a1cd4">&#9670;&#160;</a></span>binary_insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::binary_insertion_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>折半插入排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度有关（减少了比较次数但仍需移动元素）</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：中等规模数据，相比普通插入排序减少了比较次数 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a6b9e6cdd4877ca3d4ae2b903284b3c02" name="a6b9e6cdd4877ca3d4ae2b903284b3c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b9e6cdd4877ca3d4ae2b903284b3c02">&#9670;&#160;</a></span>Bisection_Method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ol::Bisection_Method </td>
          <td>(</td>
          <td class="paramtype">double(*</td>          <td class="paramname"><span class="paramname"><em>func&#160;</em></span>)(double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>low</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>high</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>max_iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>二分迭代法求解非线性方程（收敛阶P=1） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>目标函数（f(x)=0） </td></tr>
    <tr><td class="paramname">low</td><td>区间左端点 </td></tr>
    <tr><td class="paramname">high</td><td>区间右端点（需满足f(low)与f(high)异号） </td></tr>
    <tr><td class="paramname">tolerance</td><td>误差限（迭代终止条件） </td></tr>
    <tr><td class="paramname">max_iterations</td><td>最大迭代次数（默认1000，防止无限循环） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>方程的近似解 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>要求函数在[low, high]上连续且f(low)*f(high) &lt; 0 </dd></dl>

</div>
</div>
<a id="ac4eba733f62c575369a7442dafb72921" name="ac4eba733f62c575369a7442dafb72921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4eba733f62c575369a7442dafb72921">&#9670;&#160;</a></span>bubble_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::bubble_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>冒泡排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（支持双向迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度有关（可通过优化提前终止）</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：小规模数据或教学演示，实际应用中效率较低 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afd6efc10009da0b60ba08496cf1465e2" name="afd6efc10009da0b60ba08496cf1465e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6efc10009da0b60ba08496cf1465e2">&#9670;&#160;</a></span>bubble_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename Compare = std::less&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::bubble_sort </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>冒泡排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>双向迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度有关（可通过优化提前终止）</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：小规模数据或教学演示，实际应用中效率较低 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a27228a514c2c9db637e2fa559e4a28e8" name="a27228a514c2c9db637e2fa559e4a28e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27228a514c2c9db637e2fa559e4a28e8">&#9670;&#160;</a></span>bucket_sort() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename Container::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; typenameContainer::value_type &gt;::value, void &gt;::type ol::bucket_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_buckets</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>桶排序（容器版本，适用于整数） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器，元素为整数） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">num_buckets</td><td>桶数量（默认10，建议设为接近元素数量的平方根） </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，决定排序规则 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>当桶数量小于1时抛出 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>混合排序：自动划分桶，桶内使用插入排序（支持比较器）</li>
<li>稳定性：稳定排序（相等元素保持原始相对顺序）</li>
<li>时间复杂度：平均O(n + k)，最坏O(n²)（k为桶数量）<ul>
<li>性能与数据分布和初始有序度均相关：<ol type="1">
<li>当数据分布均匀时，各桶元素数量均衡，桶内插入排序效率高</li>
<li>初始有序度高时，桶内元素已有序，插入排序退化到O(m)（m为桶内元素数）</li>
<li>若数据集中在少数桶中，会退化为桶内插入排序的O(m²)，整体接近O(n²)</li>
</ol>
</li>
</ul>
</li>
<li>空间复杂度：O(n + k)，需要额外空间存储k个桶及n个元素</li>
<li>适用场景：数据分布均匀且范围已知的整数排序，尤其适合初始有序度较高的数据集 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a736b60ebf0649020725abaaee4b9a9f9" name="a736b60ebf0649020725abaaee4b9a9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736b60ebf0649020725abaaee4b9a9f9">&#9670;&#160;</a></span>bucket_sort() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename Container::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; typenameContainer::value_type &gt;::value, void &gt;::type ol::bucket_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_buckets</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>桶排序（容器版本，适用于浮点数） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器，元素为浮点数） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">num_buckets</td><td>桶数量（默认10，建议设为接近元素数量的平方根） </td></tr>
    <tr><td class="paramname">min_val</td><td>数据最小值（必须小于max_val） </td></tr>
    <tr><td class="paramname">max_val</td><td>数据最大值（必须大于min_val） </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，决定桶内元素的排序规则 </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>异常</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>当桶数量小于1或min_val &gt;= max_val时抛出 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>混合排序：桶划分基于数值范围，桶内使用插入排序（支持比较器）</li>
<li>稳定性：稳定排序（相等元素保持原始相对顺序）</li>
<li>时间复杂度：平均O(n + k)，最坏O(n²)（k为桶数量）<ul>
<li>性能与数据分布和初始有序度密切相关：<ol type="1">
<li>数据分布均匀时，各桶元素数量均衡，整体效率接近线性</li>
<li>初始有序度高时，桶内元素已有序，插入排序效率显著提升（接近O(m)）</li>
<li>数据分布不均时，元素集中在少数桶中，退化为桶内插入排序的O(m²)</li>
</ol>
</li>
</ul>
</li>
<li>空间复杂度：O(n + k)，需额外存储k个桶及所有元素</li>
<li>适用场景：数据分布均匀且范围已知的浮点数排序，尤其适合初始有序度较高的数据集 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af320799ed43dcad0f83ab6eb81564cff" name="af320799ed43dcad0f83ab6eb81564cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af320799ed43dcad0f83ab6eb81564cff">&#9670;&#160;</a></span>bucket_sort() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type ol::bucket_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_buckets</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>桶排序（迭代器版本，适用于整数） </p>
<p>与容器版本特性一致，支持自定义比较器，自动计算数据范围。 </p>

</div>
</div>
<a id="aebf9da183c7571fd920489173964fc62" name="aebf9da183c7571fd920489173964fc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf9da183c7571fd920489173964fc62">&#9670;&#160;</a></span>bucket_sort() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type ol::bucket_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_buckets</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>min_val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_val</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>桶排序（迭代器版本，适用于浮点数） </p>
<p>与容器版本特性一致，支持自定义比较器，适用于浮点数范围排序。 </p>

</div>
</div>
<a id="a8b8a16c2b2b49e295d7299a8922eb40e" name="a8b8a16c2b2b49e295d7299a8922eb40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b8a16c2b2b49e295d7299a8922eb40e">&#9670;&#160;</a></span>clearbuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; ol::clearbuf </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>清空输入缓冲区（忽略剩余字符直到换行） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>输入流 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>输入流引用 </dd></dl>

</div>
</div>
<a id="aba683542bcc3658cee4ba7a7dc5f5455" name="aba683542bcc3658cee4ba7a7dc5f5455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba683542bcc3658cee4ba7a7dc5f5455">&#9670;&#160;</a></span>copyfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::copyfile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>srcfilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dstfilename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73bd96b25ae284520474e93e504a04d7" name="a73bd96b25ae284520474e93e504a04d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73bd96b25ae284520474e93e504a04d7">&#9670;&#160;</a></span>counting_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; typenamecontainer_traits&lt; Container &gt;::value_type &gt;::value, void &gt;::type ol::counting_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计数排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器，元素类型为整数） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n + k)，n为元素个数，k为数值范围，与初始有序度无关</li>
<li>空间复杂度：O(n + k)，需要额外的存储空间</li>
<li>适用场景：整数类型数据，且数值范围相对较小的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a7f1d9815c8bbf0a5e37466b69ac4154f" name="a7f1d9815c8bbf0a5e37466b69ac4154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1d9815c8bbf0a5e37466b69ac4154f">&#9670;&#160;</a></span>counting_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type ol::counting_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>计数排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型（元素类型为整数） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n + k)，n为元素个数，k为数值范围，与初始有序度无关</li>
<li>空间复杂度：O(n + k)，需要额外的存储空间</li>
<li>适用场景：整数类型数据，且数值范围相对较小的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aaa16280e711fcd7aaa7b1b6f4a23857d" name="aaa16280e711fcd7aaa7b1b6f4a23857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa16280e711fcd7aaa7b1b6f4a23857d">&#9670;&#160;</a></span>deleteLchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::deleteLchr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除字符串左边指定字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待处理的字符串（C字符串会被直接修改，std::string为引用） </td></tr>
    <tr><td class="paramname">c</td><td>要删除的字符（默认空格' '） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>修改后的字符串（C字符串返回指针，std::string返回引用） </dd></dl>

</div>
</div>
<a id="a745779345fb05a962ec85f810354431a" name="a745779345fb05a962ec85f810354431a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745779345fb05a962ec85f810354431a">&#9670;&#160;</a></span>deleteLchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::deleteLchr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88a6fb332655c644005654d323513378" name="a88a6fb332655c644005654d323513378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a6fb332655c644005654d323513378">&#9670;&#160;</a></span>deleteLRchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::deleteLRchr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除字符串左右两边指定字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待处理的字符串（C字符串会被直接修改，std::string为引用） </td></tr>
    <tr><td class="paramname">c</td><td>要删除的字符（默认空格' '） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>修改后的字符串（C字符串返回指针，std::string返回引用） </dd></dl>

</div>
</div>
<a id="ae4294d63773fe865b4000cc5c43c902f" name="ae4294d63773fe865b4000cc5c43c902f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4294d63773fe865b4000cc5c43c902f">&#9670;&#160;</a></span>deleteLRchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::deleteLRchr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac480ad633ab9f2ed59990a7996f172b1" name="ac480ad633ab9f2ed59990a7996f172b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac480ad633ab9f2ed59990a7996f172b1">&#9670;&#160;</a></span>deleteRchr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::deleteRchr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>删除字符串右边指定字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待处理的字符串（C字符串会被直接修改，std::string为引用） </td></tr>
    <tr><td class="paramname">c</td><td>要删除的字符（默认空格' '） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>修改后的字符串（C字符串返回指针，std::string返回引用） </dd></dl>

</div>
</div>
<a id="a6c3e6a85af26aaaa9c96d687cffd8f49" name="a6c3e6a85af26aaaa9c96d687cffd8f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3e6a85af26aaaa9c96d687cffd8f49">&#9670;&#160;</a></span>deleteRchr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::deleteRchr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad40bbc392d95b486ce6ea0dc229ed00b" name="ad40bbc392d95b486ce6ea0dc229ed00b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40bbc392d95b486ce6ea0dc229ed00b">&#9670;&#160;</a></span>filemtime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::filemtime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>mtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3e74e09a9d9b181d71bda70bbe4eeaa" name="ab3e74e09a9d9b181d71bda70bbe4eeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e74e09a9d9b181d71bda70bbe4eeaa">&#9670;&#160;</a></span>filemtime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::filemtime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9678bc0f8ed0f972cf1948293d920372" name="a9678bc0f8ed0f972cf1948293d920372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9678bc0f8ed0f972cf1948293d920372">&#9670;&#160;</a></span>filesize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long ol::filesize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b6934046eb299f6624cf045d94beefd" name="a7b6934046eb299f6624cf045d94beefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6934046eb299f6624cf045d94beefd">&#9670;&#160;</a></span>getByXml() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c84b0c2d8eef3aadcce9253463cd5d3" name="a4c84b0c2d8eef3aadcce9253463cd5d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c84b0c2d8eef3aadcce9253463cd5d3">&#9670;&#160;</a></span>getByXml() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c709bf27e30aef5c100784c624134d6" name="a3c709bf27e30aef5c100784c624134d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c709bf27e30aef5c100784c624134d6">&#9670;&#160;</a></span>getByXml() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dbe1785f618ada77a6bf154c5475db5" name="a3dbe1785f618ada77a6bf154c5475db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbe1785f618ada77a6bf154c5475db5">&#9670;&#160;</a></span>getByXml() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab556e056cad32562d315e750ea0b8839" name="ab556e056cad32562d315e750ea0b8839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab556e056cad32562d315e750ea0b8839">&#9670;&#160;</a></span>getByXml() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2964a31677b6de3ef5d7ef1686999cb2" name="a2964a31677b6de3ef5d7ef1686999cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2964a31677b6de3ef5d7ef1686999cb2">&#9670;&#160;</a></span>getByXml() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab50670b26462f76a11a18ed002f00db9" name="ab50670b26462f76a11a18ed002f00db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50670b26462f76a11a18ed002f00db9">&#9670;&#160;</a></span>getByXml() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3faacb9189f20800d49da807fa74ca7e" name="a3faacb9189f20800d49da807fa74ca7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3faacb9189f20800d49da807fa74ca7e">&#9670;&#160;</a></span>getByXml() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab225c4f858f9e16809cdbfdda55e1feb" name="ab225c4f858f9e16809cdbfdda55e1feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab225c4f858f9e16809cdbfdda55e1feb">&#9670;&#160;</a></span>getByXml() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::getByXml </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>xmlStr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34677863ef2e6cb4d453190485e82f2e" name="a34677863ef2e6cb4d453190485e82f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34677863ef2e6cb4d453190485e82f2e">&#9670;&#160;</a></span>hash_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::hash_combine </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>哈希组合函数：将单个值的哈希值合并到种子中 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>待哈希的值类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>哈希种子（会被修改） </td></tr>
    <tr><td class="paramname">val</td><td>待合并的数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>采用boost库的哈希组合算法，具有良好的雪崩效应 </dd></dl>

</div>
</div>
<a id="a3bd6198b05d3159b49bf4b38c11123f5" name="a3bd6198b05d3159b49bf4b38c11123f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd6198b05d3159b49bf4b38c11123f5">&#9670;&#160;</a></span>hash_val() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ol::hash_val </td>
          <td>(</td>
          <td class="paramtype">const Types...</td>          <td class="paramname"><span class="paramname"><em>args</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>可变参数哈希计算：入口函数 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>待哈希的所有值类型列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>待计算哈希的所有数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>组合后的哈希值（std::size_t类型） </dd></dl>

</div>
</div>
<a id="aaf2df6d5aad0a8b4951d6219e5179f8b" name="aaf2df6d5aad0a8b4951d6219e5179f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2df6d5aad0a8b4951d6219e5179f8b">&#9670;&#160;</a></span>hash_val() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::hash_val </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>可变参数哈希计算：单参数版本（递归终止函数） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>待哈希的值类型 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>哈希种子（会被修改） </td></tr>
    <tr><td class="paramname">val</td><td>待哈希的数值 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a066b4213274d02ff0d3029ce1d644c27" name="a066b4213274d02ff0d3029ce1d644c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066b4213274d02ff0d3029ce1d644c27">&#9670;&#160;</a></span>hash_val() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::hash_val </td>
          <td>(</td>
          <td class="paramtype">std::size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Types...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>可变参数哈希计算：多参数递归版本 </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>第一个待哈希的值类型 </td></tr>
    <tr><td class="paramname">Types</td><td>剩余待哈希的值类型列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>哈希种子（会被修改） </td></tr>
    <tr><td class="paramname">val</td><td>第一个待哈希的数值 </td></tr>
    <tr><td class="paramname">args</td><td>剩余待哈希的数值 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>通过递归展开参数包，依次处理所有输入参数 </dd></dl>

</div>
</div>
<a id="a8f3964ed496212300b728bbc1548b059" name="a8f3964ed496212300b728bbc1548b059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3964ed496212300b728bbc1548b059">&#9670;&#160;</a></span>heap_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::heap_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>堆排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n log n)，与初始有序度无关</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：中等至大规模数据，对空间使用有严格限制的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad58d66ffb28691d52d0c8a3436efa3a1" name="ad58d66ffb28691d52d0c8a3436efa3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58d66ffb28691d52d0c8a3436efa3a1">&#9670;&#160;</a></span>heap_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::heap_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>堆排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n log n)，与初始有序度无关</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：中等至大规模数据，对空间使用有严格限制的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a355256f0b51dffd00f26de3e2629c46f" name="a355256f0b51dffd00f26de3e2629c46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355256f0b51dffd00f26de3e2629c46f">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::insertion_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>插入排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（支持迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度密切相关（接近有序时效率高）</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：小规模数据或接近有序的数据 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab6ff8f596eb0adeac5de66f9c658c253" name="ab6ff8f596eb0adeac5de66f9c658c253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ff8f596eb0adeac5de66f9c658c253">&#9670;&#160;</a></span>insertion_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename Compare = std::less&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::insertion_sort </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>插入排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>迭代器类型（支持双向迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度密切相关（接近有序时效率高）</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：小规模数据或接近有序的数据 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa8bc0ef20d6a5f982723bcc3c595c077" name="aa8bc0ef20d6a5f982723bcc3c595c077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8bc0ef20d6a5f982723bcc3c595c077">&#9670;&#160;</a></span>localtime_now()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::localtime_now </td>
          <td>(</td>
          <td class="paramtype">struct tm *</td>          <td class="paramname"><span class="paramname"><em>tm_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const time_t *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36c493150bfdebc6e1bf8730c199a586" name="a36c493150bfdebc6e1bf8730c199a586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c493150bfdebc6e1bf8730c199a586">&#9670;&#160;</a></span>ltime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::ltime </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>strtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>timetvl</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取操作系统时间并格式化为C字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strtime</td><td>用于存放结果的字符数组指针（需确保足够空间） </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式（默认"yyyy-mm-dd hh24:mi:ss"） </td></tr>
    <tr><td class="paramname">timetvl</td><td>时间偏移量（秒） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的C字符串指针 </dd></dl>

</div>
</div>
<a id="a9a0ee46add8be93066238f466ac013c4" name="a9a0ee46add8be93066238f466ac013c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0ee46add8be93066238f466ac013c4">&#9670;&#160;</a></span>ltime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::ltime </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>strtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>timetvl</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取操作系统时间并格式化为字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strtime</td><td>用于存放结果的字符串引用 </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式（默认"yyyy-mm-dd hh24:mi:ss"），支持格式见备注 </td></tr>
    <tr><td class="paramname">timetvl</td><td>时间偏移量（秒），正数为未来，负数为过去，0为当前时间 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的时间字符串引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>支持的格式包括："yyyy-mm-dd hh24:mi:ss"、"yyyymmddhh24miss"、"yyyy-mm-dd"等 </dd></dl>

</div>
</div>
<a id="a962ba22413633f2e0befb733d150aa32" name="a962ba22413633f2e0befb733d150aa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962ba22413633f2e0befb733d150aa32">&#9670;&#160;</a></span>ltime1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ol::ltime1 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>timetvl</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>获取操作系统时间并格式化为字符串（无参数重载，避免歧义） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>输出格式 </td></tr>
    <tr><td class="paramname">timetvl</td><td>时间偏移量（秒） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的时间字符串 </dd></dl>

</div>
</div>
<a id="ad26f3aeccdfe4a26275ae2408a199ace" name="ad26f3aeccdfe4a26275ae2408a199ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26f3aeccdfe4a26275ae2408a199ace">&#9670;&#160;</a></span>matchstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::matchstr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>rules</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>正则匹配字符串（支持通配符*，匹配多个任意字符） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待匹配的字符串（精确内容） </td></tr>
    <tr><td class="paramname">rules</td><td>匹配规则（用*表示多个任意字符，多规则用半角的逗号分隔，如"*.h,*.cpp"） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true-匹配成功，false-匹配失败 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>1）str参数不需要支持"*"，rules参数支持"*"； 2）函数在判断str是否匹配rules的时候，会忽略字母的大小写。 </dd></dl>

</div>
</div>
<a id="a8e7cb4d1f4074dfb13359f984db6421b" name="a8e7cb4d1f4074dfb13359f984db6421b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7cb4d1f4074dfb13359f984db6421b">&#9670;&#160;</a></span>merge_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::merge_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>归并排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n log n)，与初始有序度无关</li>
<li>空间复杂度：O(n)，需要额外的存储空间</li>
<li>适用场景：中等至大规模数据，需要稳定排序的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="afc1301e964ee0feb56c92811ad669d3c" name="afc1301e964ee0feb56c92811ad669d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1301e964ee0feb56c92811ad669d3c">&#9670;&#160;</a></span>merge_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::merge_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>归并排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：稳定排序（相等元素保持原有顺序）</li>
<li>时间复杂度：O(n log n)，与初始有序度无关</li>
<li>空间复杂度：O(n)，需要额外的存储空间</li>
<li>适用场景：中等至大规模数据，需要稳定排序的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1c82ae7c3647a9c5000f2e8bcd4cecc1" name="a1c82ae7c3647a9c5000f2e8bcd4cecc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c82ae7c3647a9c5000f2e8bcd4cecc1">&#9670;&#160;</a></span>MKDIR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ol::MKDIR </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>_Path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>_Mode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82796b31d32a613c8c1ec8423c5bfe32" name="a82796b31d32a613c8c1ec8423c5bfe32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82796b31d32a613c8c1ec8423c5bfe32">&#9670;&#160;</a></span>newdir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::newdir </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pathorfilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bisfilename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04b2c9f90ab67dc3eb8ba95a9731b250" name="a04b2c9f90ab67dc3eb8ba95a9731b250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b2c9f90ab67dc3eb8ba95a9731b250">&#9670;&#160;</a></span>Newton_Method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ol::Newton_Method </td>
          <td>(</td>
          <td class="paramtype">double(*</td>          <td class="paramname"><span class="paramname"><em>func&#160;</em></span>)(double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*</td>          <td class="paramname"><span class="paramname"><em>der_func&#160;</em></span>)(double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>initial_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>max_iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>牛顿迭代法求解非线性方程（收敛阶P=2） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>目标函数（f(x)=0） </td></tr>
    <tr><td class="paramname">der_func</td><td>目标函数的导函数（f’(x)） </td></tr>
    <tr><td class="paramname">initial_value</td><td>初始迭代值 </td></tr>
    <tr><td class="paramname">tolerance</td><td>误差限（|x_{n+1}-x_n| &lt; tolerance时终止） </td></tr>
    <tr><td class="paramname">max_iterations</td><td>最大迭代次数（默认1000） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>方程的近似解 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>要求初始值附近f’(x)≠0且函数足够光滑 </dd></dl>

</div>
</div>
<a id="a1da95e0d0c4e69dcdd873a550bf4b64c" name="a1da95e0d0c4e69dcdd873a550bf4b64c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da95e0d0c4e69dcdd873a550bf4b64c">&#9670;&#160;</a></span>nl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ol::nl </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>自定义换行操纵符（替代endl，不刷新缓冲区） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>输出流 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>输出流引用 </dd></dl>

</div>
</div>
<a id="a4b5adf474f85a8a0166456640fb6f2ec" name="a4b5adf474f85a8a0166456640fb6f2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b5adf474f85a8a0166456640fb6f2ec">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ol::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structol_1_1binary__t.html">binary_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c80a2de27f0a49c96e7884d5a904982" name="a4c80a2de27f0a49c96e7884d5a904982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c80a2de27f0a49c96e7884d5a904982">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ol::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classol_1_1ccmdstr.html">ccmdstr</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cmdstr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>重载&lt;&lt;运算符，输出ccmdstr的字段内容（调试用） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>输出流 </td></tr>
    <tr><td class="paramname">cmdstr</td><td>ccmdstr对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>输出流引用 </dd></dl>

</div>
</div>
<a id="ac81c63f2b04e9efd21292fdfe4ed7a41" name="ac81c63f2b04e9efd21292fdfe4ed7a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81c63f2b04e9efd21292fdfe4ed7a41">&#9670;&#160;</a></span>picknumber() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::picknumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bsigned</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bdot</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>从字符串中提取数字相关字符 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>源字符串 </td></tr>
    <tr><td class="paramname">dest</td><td>存储结果的目标变量（C字符串/ std::string引用，仅前两个版本需要） </td></tr>
    <tr><td class="paramname">bsigned</td><td>是否提取符号（+/-，默认false） </td></tr>
    <tr><td class="paramname">bdot</td><td>是否提取小数点（.，默认false） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>提取结果（C字符串返回指针，std::string返回引用或新字符串） </dd></dl>
<dl class="section note"><dt>注解</dt><dd>src和dest可指向同一变量（前两个版本） </dd></dl>

</div>
</div>
<a id="a4572f642a9fbea8c13a237366bb949f6" name="a4572f642a9fbea8c13a237366bb949f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4572f642a9fbea8c13a237366bb949f6">&#9670;&#160;</a></span>picknumber() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ol::picknumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bsigned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bdot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1234d4c4cabd00d7c6ec033c3b3427d9" name="a1234d4c4cabd00d7c6ec033c3b3427d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1234d4c4cabd00d7c6ec033c3b3427d9">&#9670;&#160;</a></span>picknumber() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::picknumber </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bsigned</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bdot</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab59144036437a58a1390422ea187c7b7" name="ab59144036437a58a1390422ea187c7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59144036437a58a1390422ea187c7b7">&#9670;&#160;</a></span>print_container() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::print_container </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>打印容器元素（调试用） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（支持范围for循环） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待打印的容器 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>元素类型需支持std::cout输出 </dd></dl>

</div>
</div>
<a id="a53370611a6ca69b5179649d739f98912" name="a53370611a6ca69b5179649d739f98912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53370611a6ca69b5179649d739f98912">&#9670;&#160;</a></span>print_container() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::print_container </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)</td>          <td class="paramname"><span class="paramname"><em>array</em></span>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>打印原生数组元素（调试用） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>数组元素类型 </td></tr>
    <tr><td class="paramname">N</td><td>数组大小 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>待打印的原生数组 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>元素类型需支持std::cout输出 </dd></dl>

</div>
</div>
<a id="acba072c1e10da92c9c812e46787ca8dc" name="acba072c1e10da92c9c812e46787ca8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba072c1e10da92c9c812e46787ca8dc">&#9670;&#160;</a></span>quick_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::quick_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>快速排序（容器版本） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n log n)，与初始有序度有关但影响程度取决于基准选择策略</li>
<li>空间复杂度：O(log n)，主要用于递归调用栈</li>
<li>适用场景：大多数通用排序场景，平均性能优异</li>
</ul>
</dd></dl>
<p>实现优化：</p><ul>
<li>采用三数取中法选择基准元素，减少最坏情况出现概率</li>
<li>引入阈值优化：当待排序区间长度小于等于16时，自动切换为插入排序</li>
<li>挖坑填数法替代传统交换，减少元素交换次数</li>
<li>对相等元素进行特殊处理，平衡左右分区 </li>
</ul>

</div>
</div>
<a id="a20e0ccd87e1ef5296e5b901c6d5f0691" name="a20e0ccd87e1ef5296e5b901c6d5f0691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e0ccd87e1ef5296e5b901c6d5f0691">&#9670;&#160;</a></span>quick_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::quick_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>快速排序（迭代器版本） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n log n)，与初始有序度有关但影响程度取决于基准选择策略</li>
<li>空间复杂度：O(log n)，主要用于递归调用栈</li>
<li>适用场景：大多数通用排序场景，平均性能优异</li>
</ul>
</dd></dl>
<p>实现优化：</p><ul>
<li>采用三数取中法选择基准元素，减少最坏情况出现概率</li>
<li>引入阈值优化：当待排序区间长度小于等于16时，自动切换为插入排序</li>
<li>挖坑填数法替代传统交换，减少元素交换次数</li>
<li>对相等元素进行特殊处理，平衡左右分区 </li>
</ul>

</div>
</div>
<a id="ae7766935138c272ea6c5c41d97b8f9d2" name="ae7766935138c272ea6c5c41d97b8f9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7766935138c272ea6c5c41d97b8f9d2">&#9670;&#160;</a></span>radix_group_by_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typenamecontainer_traits&lt; Container &gt;::value_type, std::string &gt;::value, std::vector&lt; Container &gt; &gt;::type ol::radix_group_by_prefix </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>group_pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>按字符串前缀分组（基于基数排序MSD） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（元素为string，需支持随机访问迭代器） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待分组的容器 </td></tr>
    <tr><td class="paramname">group_pos</td><td>按前几位分组（必须&gt;=1） </td></tr>
    <tr><td class="paramname">radix</td><td>基数（字符集大小，默认256） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>分组结果，每个子容器包含前缀相同的字符串 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>分组结果内部已按MSD排序 </dd></dl>

</div>
</div>
<a id="aca3ac38ec67c0284d769deb7d7a543ae" name="aca3ac38ec67c0284d769deb7d7a543ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3ac38ec67c0284d769deb7d7a543ae">&#9670;&#160;</a></span>radix_sort_lsd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; typenamecontainer_traits&lt; Container &gt;::value_type &gt;::value, void &gt;::type ol::radix_sort_lsd </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基数排序（容器版本，LSD策略，适用于整数类型） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器，元素为整数） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较器类型，仅支持std::less（升序）和std::greater（降序） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">radix</td><td>基数，默认为10（十进制） </td></tr>
    <tr><td class="paramname">comp</td><td>比较器，std::less为升序，std::greater为降序 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>非比较型排序，基于数字位数特性实现</li>
<li>稳定性：稳定排序（相等元素保持原始相对顺序）</li>
<li>时间复杂度：O(d*(n+r))，d为最大位数，n为元素数，r为基数</li>
<li>支持升序（默认，使用std::less）和降序（使用std::greater）</li>
<li>降序通过"先升序排序，再反转结果"实现 适用场景：</li>
<li>待排序元素为**整数类型**（如int、long、unsigned int等）的场景</li>
<li>元素取值范围较大，但**位数d较小且固定**的场景（如手机号、身份证号、固定长度编码）</li>
<li>对排序稳定性有要求，且需避免比较型排序最坏情况（如O(n²)）的场景</li>
<li>数据量较大（n较大），且基数r选择合理（如2^8=256，适配内存操作）的场景</li>
<li>不适用场景：非整数类型数据、位数差异极大且最大值位数d远大于log_r n的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ad3a7ae1e3c04b9fb3fe03a8c01767965" name="ad3a7ae1e3c04b9fb3fe03a8c01767965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a7ae1e3c04b9fb3fe03a8c01767965">&#9670;&#160;</a></span>radix_sort_lsd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_integral&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type &gt;::value, void &gt;::type ol::radix_sort_lsd </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基数排序（迭代器版本，LSD策略，适用于整数类型） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较器类型，仅支持std::less（升序）和std::greater（降序） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>排序区间的起始迭代器（包含） </td></tr>
    <tr><td class="paramname">last</td><td>排序区间的结束迭代器（不包含） </td></tr>
    <tr><td class="paramname">radix</td><td>基数，默认为10（十进制） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>非比较型排序，基于数字位数特性实现</li>
<li>稳定性：稳定排序（相等元素保持原始相对顺序）</li>
<li>时间复杂度：O(d*(n+r))，d为最大位数，n为元素数，r为基数</li>
<li>支持升序（默认，使用std::less）和降序（使用std::greater）</li>
<li>降序通过"先升序排序，再反转结果"实现 适用场景：</li>
<li>待排序元素为**整数类型**（如int、long、unsigned int等）的场景</li>
<li>元素取值范围较大，但**位数d较小且固定**的场景（如手机号、身份证号、固定长度编码）</li>
<li>对排序稳定性有要求，且需避免比较型排序最坏情况（如O(n²)）的场景</li>
<li>数据量较大（n较大），且基数r选择合理（如2^8=256，适配内存操作）的场景</li>
<li>不适用场景：非整数类型数据、位数差异极大且最大值位数d远大于log_r n的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1673c8a78bd795b8fc12136ddb75abd7" name="a1673c8a78bd795b8fc12136ddb75abd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1673c8a78bd795b8fc12136ddb75abd7">&#9670;&#160;</a></span>radix_sort_msd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typenamecontainer_traits&lt; Container &gt;::value_type, std::string &gt;::value, void &gt;::type ol::radix_sort_msd </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基数排序（容器版本，MSD策略，字符串专用） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（元素为string，需支持随机访问迭代器） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">max_pos</td><td>最大处理位数（-1表示处理全部字符，默认-1） </td></tr>
    <tr><td class="paramname">radix</td><td>基数（字符集大小，默认256支持所有ASCII字符） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>非比较型排序，基于字符高位优先策略</li>
<li>稳定性：稳定排序（相等元素保持原始相对顺序）</li>
<li>时间复杂度：O(d*(n + r))，d为最大字符串长度，n为元素数，r为基数</li>
<li>空间复杂度：O(n + r)，需要额外存储空间 适用场景：</li>
<li>字符串排序（尤其是变长字符串）</li>
<li>高位差异明显的数据（如按首字母排序的单词表）</li>
<li>需要按前缀进行分组的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab3b54338a25c60a7d48ee493209d675e" name="ab3b54338a25c60a7d48ee493209d675e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b54338a25c60a7d48ee493209d675e">&#9670;&#160;</a></span>radix_sort_msd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typenamestd::iterator_traits&lt; RandomIt &gt;::value_type, std::string &gt;::value, void &gt;::type ol::radix_sort_msd </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>max_pos</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>radix</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基数排序（迭代器版本，MSD策略，字符串专用） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型（元素为string） </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">max_pos</td><td>最大处理位数（-1表示处理全部字符，默认-1） </td></tr>
    <tr><td class="paramname">radix</td><td>基数（字符集大小，默认256支持所有ASCII字符） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cdca00eeb0b403f77ac67300e093843" name="a8cdca00eeb0b403f77ac67300e093843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdca00eeb0b403f77ac67300e093843">&#9670;&#160;</a></span>renamefile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::renamefile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>srcfilename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dstfilename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acac3b36117c350b30d7627c06dee201c" name="acac3b36117c350b30d7627c06dee201c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac3b36117c350b30d7627c06dee201c">&#9670;&#160;</a></span>replacestr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::replacestr </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>bloop</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>字符串替换 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待处理的字符串（C字符串会被直接修改，std::string为引用） </td></tr>
    <tr><td class="paramname">str1</td><td>要替换的旧子串 </td></tr>
    <tr><td class="paramname">str2</td><td>替换的新子串 </td></tr>
    <tr><td class="paramname">bloop</td><td>是否循环替换（默认false） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true-替换成功，false-替换失败（如存在逻辑错误） </dd></dl>
<dl class="section note"><dt>注解</dt><dd>1、如果str2比str1要长，替换后str会变长，C字符串需保证足够空间（std::string无此问题）。 2、如果str2中包含str1且bloop为true，存在逻辑错误，函数将不执行操作。 3、如果str2为空，表示删除str中所有str1的内容。 </dd></dl>

</div>
</div>
<a id="a6efd74ce91343f9d51b7820f4b65663b" name="a6efd74ce91343f9d51b7820f4b65663b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efd74ce91343f9d51b7820f4b65663b">&#9670;&#160;</a></span>replacestr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::replacestr </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bloop</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c04a27f537065c8da7b1b676535ca94" name="a1c04a27f537065c8da7b1b676535ca94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c04a27f537065c8da7b1b676535ca94">&#9670;&#160;</a></span>Secant_Method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ol::Secant_Method </td>
          <td>(</td>
          <td class="paramtype">double(*</td>          <td class="paramname"><span class="paramname"><em>func&#160;</em></span>)(double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>initial_value_0</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>initial_value_1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>max_iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isFixedPoint_0</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>弦截迭代法求解非线性方程（收敛阶P=1.618） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>目标函数（f(x)=0） </td></tr>
    <tr><td class="paramname">initial_value_0</td><td>初始迭代值0 </td></tr>
    <tr><td class="paramname">initial_value_1</td><td>初始迭代值1 </td></tr>
    <tr><td class="paramname">tolerance</td><td>误差限（|x_{n+1}-x_n| &lt; tolerance时终止） </td></tr>
    <tr><td class="paramname">max_iterations</td><td>最大迭代次数（默认1000） </td></tr>
    <tr><td class="paramname">isFixedPoint_0</td><td>是否使用固定端点模式（固定initial_value_0，默认false为变端点模式） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>方程的近似解 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>无需计算导数，收敛速度快于二分法，慢于牛顿法 </dd></dl>

</div>
</div>
<a id="a30335079a85487d189df8d7746b28a04" name="a30335079a85487d189df8d7746b28a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30335079a85487d189df8d7746b28a04">&#9670;&#160;</a></span>selection_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::selection_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>选择排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（支持迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度无关</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：小规模数据，交换操作成本较高的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab5050dfa7769d72e80979b03d5838d47" name="ab5050dfa7769d72e80979b03d5838d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5050dfa7769d72e80979b03d5838d47">&#9670;&#160;</a></span>selection_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator, typename Compare = std::less&lt;typename std::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::selection_sort </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>选择排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator</td><td>迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n²)，与初始有序度无关</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：小规模数据，交换操作成本较高的场景 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a4fee6ef354270ebe2c9a5bc156dfad87" name="a4fee6ef354270ebe2c9a5bc156dfad87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fee6ef354270ebe2c9a5bc156dfad87">&#9670;&#160;</a></span>setmtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::setmtime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>mtime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac494558d01c7d5be3f87d20b0a558f2" name="aac494558d01c7d5be3f87d20b0a558f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac494558d01c7d5be3f87d20b0a558f2">&#9670;&#160;</a></span>sformat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string ol::sformat </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>格式化输出函数（返回新字符串） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>可变参数类型列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>格式字符串（C风格） </td></tr>
    <tr><td class="paramname">args</td><td>待格式化的参数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的新字符串 </dd></dl>

</div>
</div>
<a id="a9be60c7b808dd3c1f3545e4fb187b276" name="a9be60c7b808dd3c1f3545e4fb187b276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be60c7b808dd3c1f3545e4fb187b276">&#9670;&#160;</a></span>sformat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ol::sformat </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Types &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>格式化输出函数（写入已有字符串） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Types</td><td>可变参数类型列表 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>存储结果的字符串引用 </td></tr>
    <tr><td class="paramname">fmt</td><td>格式字符串（C风格） </td></tr>
    <tr><td class="paramname">args</td><td>待格式化的参数 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>true-格式化成功，false-失败 </dd></dl>

</div>
</div>
<a id="abc5f5010f28529925ffb01055683d42c" name="abc5f5010f28529925ffb01055683d42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5f5010f28529925ffb01055683d42c">&#9670;&#160;</a></span>shell_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container, typename Compare = std::less&lt;typename container_traits&lt;Container&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::shell_sort </td>
          <td>(</td>
          <td class="paramtype">Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>希尔排序（容器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>容器类型（需支持随机访问迭代器） </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>待排序的容器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n^1.3)~O(n²)，与初始有序度和步长序列有关</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：中等规模数据，比普通插入排序效率高 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a14ba777d836ccf56aa6eeeaaf0230e34" name="a14ba777d836ccf56aa6eeeaaf0230e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ba777d836ccf56aa6eeeaaf0230e34">&#9670;&#160;</a></span>shell_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomIt, typename Compare = std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ol::shell_sort </td>
          <td>(</td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt</td>          <td class="paramname"><span class="paramname"><em>last</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Compare &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span><span class="paramdefsep"> = </span><span class="paramdefval">Compare()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>希尔排序（迭代器版本，支持默认比较器） </p>
<dl class="tparams"><dt>模板参数</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomIt</td><td>随机访问迭代器类型 </td></tr>
    <tr><td class="paramname">Compare</td><td>比较函数类型，需满足严格弱序，默认使用std::less </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>起始迭代器 </td></tr>
    <tr><td class="paramname">last</td><td>结束迭代器 </td></tr>
    <tr><td class="paramname">comp</td><td>比较函数对象，返回true表示第一个参数应排在前面 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>注解</dt><dd>算法特性：<ul>
<li>稳定性：不稳定排序（相等元素可能改变相对顺序）</li>
<li>时间复杂度：O(n^1.3)~O(n²)，与初始有序度和步长序列有关</li>
<li>空间复杂度：O(1)，原地排序</li>
<li>适用场景：中等规模数据，比普通插入排序效率高 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af1d7513132d32e7236d0c253e16fcb0f" name="af1d7513132d32e7236d0c253e16fcb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d7513132d32e7236d0c253e16fcb0f">&#9670;&#160;</a></span>Simple_Iteration_Method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ol::Simple_Iteration_Method </td>
          <td>(</td>
          <td class="paramtype">double(*</td>          <td class="paramname"><span class="paramname"><em>iter_func&#160;</em></span>)(double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>initial_value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t</td>          <td class="paramname"><span class="paramname"><em>max_iterations</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1000</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>简单迭代法求解非线性方程（收敛阶P=1） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter_func</td><td>迭代函数（x_{n+1} = iter_func(x_n)） </td></tr>
    <tr><td class="paramname">initial_value</td><td>初始迭代值 </td></tr>
    <tr><td class="paramname">tolerance</td><td>误差限（|x_{n+1}-x_n| &lt; tolerance时终止） </td></tr>
    <tr><td class="paramname">max_iterations</td><td>最大迭代次数（默认1000） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>方程的近似解 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>要求迭代函数在迭代区间内满足收敛条件（导数绝对值小于1） </dd></dl>

</div>
</div>
<a id="a893e7d35ae9b6ac8e3cb9570ccf72894" name="a893e7d35ae9b6ac8e3cb9570ccf72894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893e7d35ae9b6ac8e3cb9570ccf72894">&#9670;&#160;</a></span>skmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ol::skmp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>KMP算法查找子串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>主字符串 </td></tr>
    <tr><td class="paramname">pattern</td><td>待查找的子串（模式串） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>子串在主串中首次出现的位置（从0开始），未找到返回std::string::npos </dd></dl>

</div>
</div>
<a id="a8ab0387cd3663518222d4fc4b0d5cc0b" name="a8ab0387cd3663518222d4fc4b0d5cc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ab0387cd3663518222d4fc4b0d5cc0b">&#9670;&#160;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep, typename Period&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::sleep </td>
          <td>(</td>
          <td class="paramtype">std::chrono::duration&lt; Rep, Period &gt;</td>          <td class="paramname"><span class="paramname"><em>duration</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>通用休眠函数（支持任意时间单位） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">duration</td><td>休眠时长（std::chrono::duration类型） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82a6a51dbf9dc8c1ba527e70b1f8707c" name="a82a6a51dbf9dc8c1ba527e70b1f8707c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6a51dbf9dc8c1ba527e70b1f8707c">&#9670;&#160;</a></span>sleep_ms()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::sleep_ms </td>
          <td>(</td>
          <td class="paramtype">long long</td>          <td class="paramname"><span class="paramname"><em>milliseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>毫秒级休眠 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">milliseconds</td><td>休眠时长（毫秒） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee164d17dc0777c945a2dd47bbd8443f" name="aee164d17dc0777c945a2dd47bbd8443f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee164d17dc0777c945a2dd47bbd8443f">&#9670;&#160;</a></span>sleep_ns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::sleep_ns </td>
          <td>(</td>
          <td class="paramtype">long long</td>          <td class="paramname"><span class="paramname"><em>nanoseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>纳秒级休眠 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">nanoseconds</td><td>休眠时长（纳秒） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac624dba15a65798fc097dc515022c249" name="ac624dba15a65798fc097dc515022c249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac624dba15a65798fc097dc515022c249">&#9670;&#160;</a></span>sleep_sec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::sleep_sec </td>
          <td>(</td>
          <td class="paramtype">long long</td>          <td class="paramname"><span class="paramname"><em>seconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>秒级休眠 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>休眠时长（秒） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48224ad9e2c21e51b9e301c287cd3aa0" name="a48224ad9e2c21e51b9e301c287cd3aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48224ad9e2c21e51b9e301c287cd3aa0">&#9670;&#160;</a></span>sleep_us()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ol::sleep_us </td>
          <td>(</td>
          <td class="paramtype">long long</td>          <td class="paramname"><span class="paramname"><em>microseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>微秒级休眠 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">microseconds</td><td>休眠时长（微秒） </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a784ec116a1e64ce61b14a1b727ef474f" name="a784ec116a1e64ce61b14a1b727ef474f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784ec116a1e64ce61b14a1b727ef474f">&#9670;&#160;</a></span>strtotime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">time_t ol::strtotime </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>strtime</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将字符串转换为时间戳 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">strtime</td><td>包含完整时间信息的字符串（需包含yyyymmddhh24miss） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>对应的时间戳，格式错误时返回-1 </dd></dl>

</div>
</div>
<a id="a928e01ea34268dd0f9f61c80c6c31ffe" name="a928e01ea34268dd0f9f61c80c6c31ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928e01ea34268dd0f9f61c80c6c31ffe">&#9670;&#160;</a></span>timetostr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::timetostr </td>
          <td>(</td>
          <td class="paramtype">const time_t</td>          <td class="paramname"><span class="paramname"><em>ttime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>strtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将时间戳转换为指定格式的C字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttime</td><td>时间戳（time_t类型） </td></tr>
    <tr><td class="paramname">strtime</td><td>用于存放结果的字符数组指针 </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的C字符串指针 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果fmt的格式不正确，strtime将为空 </dd></dl>

</div>
</div>
<a id="a2c55f2b104a188a483760fb331340dc3" name="a2c55f2b104a188a483760fb331340dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c55f2b104a188a483760fb331340dc3">&#9670;&#160;</a></span>timetostr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::timetostr </td>
          <td>(</td>
          <td class="paramtype">const time_t</td>          <td class="paramname"><span class="paramname"><em>ttime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>strtime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将时间戳转换为指定格式的字符串 </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttime</td><td>时间戳（time_t类型） </td></tr>
    <tr><td class="paramname">strtime</td><td>用于存放结果的字符串引用 </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式（默认"yyyy-mm-dd hh24:mi:ss"） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的时间字符串引用 </dd></dl>
<dl class="section note"><dt>注解</dt><dd>如果fmt的格式不正确，strtime将为空 </dd></dl>

</div>
</div>
<a id="ab4a3cda5dddfd5f15e708b6709b7d375" name="ab4a3cda5dddfd5f15e708b6709b7d375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a3cda5dddfd5f15e708b6709b7d375">&#9670;&#160;</a></span>timetostr1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ol::timetostr1 </td>
          <td>(</td>
          <td class="paramtype">const time_t</td>          <td class="paramname"><span class="paramname"><em>ttime</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fmt</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将时间戳转换为指定格式的字符串（无参数重载，避免歧义） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">ttime</td><td>时间戳（time_t类型） </td></tr>
    <tr><td class="paramname">fmt</td><td>输出格式 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>格式化后的时间字符串 </dd></dl>

</div>
</div>
<a id="a251bbe056574349c9b660013001d8120" name="a251bbe056574349c9b660013001d8120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251bbe056574349c9b660013001d8120">&#9670;&#160;</a></span>tolower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::tolower </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将字符串中的大写字母转换为小写（非字母字符不变） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待转换的字符串（C字符串会被直接修改，std::string为引用） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>修改后的字符串（C字符串返回指针，std::string返回引用） </dd></dl>

</div>
</div>
<a id="a5a85db488b024565411ab4fe77f00c43" name="a5a85db488b024565411ab4fe77f00c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a85db488b024565411ab4fe77f00c43">&#9670;&#160;</a></span>tolower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::tolower </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f3142917106949a00dbabce5cd4dd62" name="a3f3142917106949a00dbabce5cd4dd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3142917106949a00dbabce5cd4dd62">&#9670;&#160;</a></span>toupper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * ol::toupper </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将字符串中的小写字母转换为大写（非字母字符不变） </p>
<dl class="params"><dt>参数</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>待转换的字符串（C字符串会被直接修改，std::string为引用） </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>返回</dt><dd>修改后的字符串（C字符串返回指针，std::string返回引用） </dd></dl>

</div>
</div>
<a id="ace14bdaa9a2d54bff9ba3b43e3f4f079" name="ace14bdaa9a2d54bff9ba3b43e3f4f079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace14bdaa9a2d54bff9ba3b43e3f4f079">&#9670;&#160;</a></span>toupper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; ol::toupper </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">变量说明</h2>
<a id="a1c4c2cb1e688fe4d998860c92537f43c" name="a1c4c2cb1e688fe4d998860c92537f43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4c2cb1e688fe4d998860c92537f43c">&#9670;&#160;</a></span>IsTypeEmpty_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ol::IsTypeEmpty_v = <a class="el" href="structol_1_1_is_type_empty.html">IsTypeEmpty</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel constexpr">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceol.html">ol</a></li>
    <li class="footer">制作者 <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
